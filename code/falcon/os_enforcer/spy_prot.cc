// -*-c++-*-
/* This file was automatically generated by rpcc. */

#include "spy_prot.h"

#ifdef MAINTAINER

const strbuf &
rpc_print (const strbuf &sb, const spy_status &obj, int recdepth,
           const char *name, const char *prefix)
{
  const char *p;
  switch (obj) {
  case FALCON_SUCCESS:
    p = "FALCON_SUCCESS";
    break;
  case FALCON_UNKNOWN_TARGET:
    p = "FALCON_UNKNOWN_TARGET";
    break;
  case FALCON_BAD_GEN_VEC:
    p = "FALCON_BAD_GEN_VEC";
    break;
  case FALCON_FUTURE_GEN:
    p = "FALCON_FUTURE_GEN";
    break;
  case FALCON_LONG_DEAD:
    p = "FALCON_LONG_DEAD";
    break;
  case FALCON_REGISTER_ACK:
    p = "FALCON_REGISTER_ACK";
    break;
  case FALCON_CANCEL_ACK:
    p = "FALCON_CANCEL_ACK";
    break;
  case FALCON_CANCEL_ERROR:
    p = "FALCON_CANCEL_ERROR";
    break;
  case FALCON_KILL_ACK:
    p = "FALCON_KILL_ACK";
    break;
  case FALCON_GEN_RESP:
    p = "FALCON_GEN_RESP";
    break;
  case FALCON_UP:
    p = "FALCON_UP";
    break;
  case FALCON_DOWN:
    p = "FALCON_DOWN";
    break;
  case FALCON_UNKNOWN_ERROR:
    p = "FALCON_UNKNOWN_ERROR";
    break;
  default:
    p = NULL;
    break;
  }
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "spy_status " << name << " = ";
  };
  if (p)
    sb << p;
  else
    sb << int (obj);
  if (prefix)
    sb << ";\n";
  return sb;
};
void
print_spy_status (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const spy_status *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_spy_status (const spy_status *objp)
{
  rpc_print (warnx, *objp);
}

void
print_status_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const status_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_status_t (const status_t *objp)
{
  rpc_print (warnx, *objp);
}

void
print_gen_no (const void *_objp, const strbuf *_sbp, int _recdepth,
              const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const gen_no *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_gen_no (const gen_no *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const target_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "target_t " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.handle, recdepth, "handle", npref);
  sb << sep;
  rpc_print (sb, obj.generation, recdepth, "generation", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_target_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const target_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_target_t (const target_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const client_addr_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "client_addr_t " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.ipaddr, recdepth, "ipaddr", npref);
  sb << sep;
  rpc_print (sb, obj.port, recdepth, "port", npref);
  sb << sep;
  rpc_print (sb, obj.client_tag, recdepth, "client_tag", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_client_addr_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                     const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const client_addr_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_client_addr_t (const client_addr_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const spy_register_arg &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "spy_register_arg " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.target, recdepth, "target", npref);
  sb << sep;
  rpc_print (sb, obj.lethal, recdepth, "lethal", npref);
  sb << sep;
  rpc_print (sb, obj.up_interval_ms, recdepth, "up_interval_ms", npref);
  sb << sep;
  rpc_print (sb, obj.client, recdepth, "client", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_spy_register_arg (const void *_objp, const strbuf *_sbp, int _recdepth,
                        const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const spy_register_arg *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_spy_register_arg (const spy_register_arg *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const spy_cancel_arg &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "spy_cancel_arg " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.target, recdepth, "target", npref);
  sb << sep;
  rpc_print (sb, obj.client, recdepth, "client", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_spy_cancel_arg (const void *_objp, const strbuf *_sbp, int _recdepth,
                      const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const spy_cancel_arg *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_spy_cancel_arg (const spy_cancel_arg *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const spy_kill_arg &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "spy_kill_arg " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.target, recdepth, "target", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_spy_kill_arg (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const spy_kill_arg *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_spy_kill_arg (const spy_kill_arg *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const spy_get_gen_arg &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "spy_get_gen_arg " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.target, recdepth, "target", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_spy_get_gen_arg (const void *_objp, const strbuf *_sbp, int _recdepth,
                       const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const spy_get_gen_arg *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_spy_get_gen_arg (const spy_get_gen_arg *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const spy_res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "spy_res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.target, recdepth, "target", npref);
  sb << sep;
  rpc_print (sb, obj.status, recdepth, "status", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_spy_res (const void *_objp, const strbuf *_sbp, int _recdepth,
               const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const spy_res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_spy_res (const spy_res *objp)
{
  rpc_print (warnx, *objp);
}

#endif /* MAINTAINER*/
void *
spy_status_alloc ()
{
  return New spy_status;
}
bool_t
xdr_spy_status (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<spy_status *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<spy_status *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
status_t_alloc ()
{
  return New status_t;
}
bool_t
xdr_status_t (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<status_t *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<status_t *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
gen_no_alloc ()
{
  return New gen_no;
}
bool_t
xdr_gen_no (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<gen_no *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<gen_no *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
target_t_alloc ()
{
  return New target_t;
}
bool_t
xdr_target_t (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<target_t *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<target_t *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
client_addr_t_alloc ()
{
  return New client_addr_t;
}
bool_t
xdr_client_addr_t (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<client_addr_t *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<client_addr_t *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
spy_register_arg_alloc ()
{
  return New spy_register_arg;
}
bool_t
xdr_spy_register_arg (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<spy_register_arg *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<spy_register_arg *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
spy_cancel_arg_alloc ()
{
  return New spy_cancel_arg;
}
bool_t
xdr_spy_cancel_arg (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<spy_cancel_arg *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<spy_cancel_arg *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
spy_kill_arg_alloc ()
{
  return New spy_kill_arg;
}
bool_t
xdr_spy_kill_arg (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<spy_kill_arg *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<spy_kill_arg *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
spy_get_gen_arg_alloc ()
{
  return New spy_get_gen_arg;
}
bool_t
xdr_spy_get_gen_arg (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<spy_get_gen_arg *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<spy_get_gen_arg *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
spy_res_alloc ()
{
  return New spy_res;
}
bool_t
xdr_spy_res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<spy_res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<spy_res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

static const rpcgen_table spy_prog_1_tbl[] = {
  SPY_PROG_1_APPLY (XDRTBL_DECL)
};
const rpc_program spy_prog_1 = {
  SPY_PROG, SPY_V1, spy_prog_1_tbl,
  sizeof (spy_prog_1_tbl) / sizeof (spy_prog_1_tbl[0]),
  "spy_prog_1"
};


