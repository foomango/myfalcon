// -*-c++-*-
/* This file was automatically generated by rpcc. */

#include "obs_prot.h"

#ifdef MAINTAINER

const strbuf &
rpc_print (const strbuf &sb, const obs_register_arg &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "obs_register_arg " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.handle, recdepth, "handle", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_obs_register_arg (const void *_objp, const strbuf *_sbp, int _recdepth,
                        const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const obs_register_arg *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_obs_register_arg (const obs_register_arg *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const obs_cancel_arg &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "obs_cancel_arg " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.handle, recdepth, "handle", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_obs_cancel_arg (const void *_objp, const strbuf *_sbp, int _recdepth,
                      const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const obs_cancel_arg *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_obs_cancel_arg (const obs_cancel_arg *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const obs_register_response &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "obs_register_response " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.generation, recdepth, "generation", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_obs_register_response (const void *_objp, const strbuf *_sbp, int _recdepth,
                             const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const obs_register_response *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_obs_register_response (const obs_register_response *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const obs_probe_msg &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "obs_probe_msg " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.counter, recdepth, "counter", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_obs_probe_msg (const void *_objp, const strbuf *_sbp, int _recdepth,
                     const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const obs_probe_msg *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_obs_probe_msg (const obs_probe_msg *objp)
{
  rpc_print (warnx, *objp);
}

#endif /* MAINTAINER*/
void *
obs_register_arg_alloc ()
{
  return New obs_register_arg;
}
bool_t
xdr_obs_register_arg (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<obs_register_arg *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<obs_register_arg *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
obs_cancel_arg_alloc ()
{
  return New obs_cancel_arg;
}
bool_t
xdr_obs_cancel_arg (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<obs_cancel_arg *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<obs_cancel_arg *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
obs_register_response_alloc ()
{
  return New obs_register_response;
}
bool_t
xdr_obs_register_response (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<obs_register_response *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<obs_register_response *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
obs_probe_msg_alloc ()
{
  return New obs_probe_msg;
}
bool_t
xdr_obs_probe_msg (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<obs_probe_msg *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<obs_probe_msg *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

static const rpcgen_table vmm_obs_prog_1_tbl[] = {
  VMM_OBS_PROG_1_APPLY (XDRTBL_DECL)
};
const rpc_program vmm_obs_prog_1 = {
  VMM_OBS_PROG, VMM_OBS_V1, vmm_obs_prog_1_tbl,
  sizeof (vmm_obs_prog_1_tbl) / sizeof (vmm_obs_prog_1_tbl[0]),
  "vmm_obs_prog_1"
};


