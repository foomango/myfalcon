// -*-c++-*-
/* This file was automatically generated by rpcc. */

#ifndef __RPCC_SPY_PROT_H_INCLUDED__
#define __RPCC_SPY_PROT_H_INCLUDED__ 1

#include "xdrmisc.h"

enum spy_status {
  FALCON_SUCCESS = 0,
  FALCON_UNKNOWN_TARGET = 1,
  FALCON_BAD_GEN_VEC = 2,
  FALCON_FUTURE_GEN = 3,
  FALCON_LONG_DEAD = 4,
  FALCON_REGISTER_ACK = 5,
  FALCON_CANCEL_ACK = 6,
  FALCON_CANCEL_ERROR = 7,
  FALCON_KILL_ACK = 8,
  FALCON_GEN_RESP = 9,
  FALCON_UP = 10,
  FALCON_DOWN = 11,
  FALCON_UNKNOWN_ERROR = 12,
};
void *spy_status_alloc ();
bool_t xdr_spy_status (XDR *, void *);
RPC_ENUM_DECL (spy_status)
TYPE2STRUCT( , spy_status);

template<class T> inline bool
rpc_traverse (T &t, spy_status &obj)
{
  u_int32_t val = obj;
  if (!rpc_traverse (t, val))
    return false;
  obj = spy_status (val);
  return true;
}

typedef uint32_t status_t;
void *status_t_alloc ();
bool_t xdr_status_t (XDR *, void *);
RPC_TYPEDEF_DECL (status_t)

typedef uint32_t gen_no;
void *gen_no_alloc ();
bool_t xdr_gen_no (XDR *, void *);
RPC_TYPEDEF_DECL (gen_no)


struct target_t {
  rpc_str<RPC_INFINITY> handle;
  rpc_vec<gen_no, RPC_INFINITY> generation;
};
void *target_t_alloc ();
bool_t xdr_target_t (XDR *, void *);
RPC_STRUCT_DECL (target_t)

template<class T> bool
rpc_traverse (T &t, target_t &obj)
{
  return rpc_traverse (t, obj.handle)
    && rpc_traverse (t, obj.generation);
}



struct client_addr_t {
  uint32_t ipaddr;
  uint32_t port;
  uint32_t client_tag;
};
void *client_addr_t_alloc ();
bool_t xdr_client_addr_t (XDR *, void *);
RPC_STRUCT_DECL (client_addr_t)

template<class T> bool
rpc_traverse (T &t, client_addr_t &obj)
{
  return rpc_traverse (t, obj.ipaddr)
    && rpc_traverse (t, obj.port)
    && rpc_traverse (t, obj.client_tag);
}



struct spy_register_arg {
  target_t target;
  bool lethal;
  int32_t up_interval_ms;
  client_addr_t client;
};
void *spy_register_arg_alloc ();
bool_t xdr_spy_register_arg (XDR *, void *);
RPC_STRUCT_DECL (spy_register_arg)

template<class T> bool
rpc_traverse (T &t, spy_register_arg &obj)
{
  return rpc_traverse (t, obj.target)
    && rpc_traverse (t, obj.lethal)
    && rpc_traverse (t, obj.up_interval_ms)
    && rpc_traverse (t, obj.client);
}



struct spy_cancel_arg {
  target_t target;
  client_addr_t client;
};
void *spy_cancel_arg_alloc ();
bool_t xdr_spy_cancel_arg (XDR *, void *);
RPC_STRUCT_DECL (spy_cancel_arg)

template<class T> bool
rpc_traverse (T &t, spy_cancel_arg &obj)
{
  return rpc_traverse (t, obj.target)
    && rpc_traverse (t, obj.client);
}



struct spy_kill_arg {
  target_t target;
};
void *spy_kill_arg_alloc ();
bool_t xdr_spy_kill_arg (XDR *, void *);
RPC_STRUCT_DECL (spy_kill_arg)

template<class T> inline bool
rpc_traverse (T &t, spy_kill_arg &obj)
{
  return rpc_traverse (t, obj.target);
}



struct spy_get_gen_arg {
  target_t target;
};
void *spy_get_gen_arg_alloc ();
bool_t xdr_spy_get_gen_arg (XDR *, void *);
RPC_STRUCT_DECL (spy_get_gen_arg)

template<class T> inline bool
rpc_traverse (T &t, spy_get_gen_arg &obj)
{
  return rpc_traverse (t, obj.target);
}



struct spy_res {
  target_t target;
  status_t status;
};
void *spy_res_alloc ();
bool_t xdr_spy_res (XDR *, void *);
RPC_STRUCT_DECL (spy_res)

template<class T> bool
rpc_traverse (T &t, spy_res &obj)
{
  return rpc_traverse (t, obj.target)
    && rpc_traverse (t, obj.status);
}


#ifndef SPY_PROG
#define SPY_PROG 2000111
#endif /* !SPY_PROG */
extern const rpc_program spy_prog_1;
enum { SPY_V1 = 1 };
enum {
  SPY_NULL = 0,
  SPY_REGISTER = 1,
  SPY_CANCEL = 2,
  SPY_KILL = 3,
  SPY_GET_GEN = 4,
};
#define SPY_PROG_1_APPLY_NOVOID(macro, void) \
  macro (SPY_NULL, void, void) \
  macro (SPY_REGISTER, spy_register_arg, spy_res) \
  macro (SPY_CANCEL, spy_cancel_arg, spy_res) \
  macro (SPY_KILL, spy_kill_arg, spy_res) \
  macro (SPY_GET_GEN, spy_get_gen_arg, spy_res)
#define SPY_PROG_1_APPLY(macro) \
  SPY_PROG_1_APPLY_NOVOID(macro, void)

#endif /* !__RPCC_SPY_PROT_H_INCLUDED__ */
